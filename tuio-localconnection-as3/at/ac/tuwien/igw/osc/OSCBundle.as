package at.ac.tuwien.igw.osc {		import flash.utils.ByteArray;		/**	 * An OSCBundle	 * @author Immanuel Bauer	 */	public class OSCBundle extends OSCPacket {				private var contentBytes:ByteArray;		private var content:Array;				private var timeSeconds:uint;		private var timePicoseconds:uint;		private var date:Date;				private const SECONDS_1900_1970:uint = 2208988800;				/**		 * Creates a OSCBundle from the given ByteArray containing binary coded OSCBundle		 * 		 * @param	bytes ByteArray containing OSC data		 */		public function OSCBundle(bytes:ByteArray) {			super(bytes);						//skip the OSC Bundle head			this.bytes.readUTFBytes(8);						//get OSC timestamp			this.timeSeconds = this.bytes.readUnsignedInt();			this.timePicoseconds = this.bytes.readUnsignedInt();						//copy remaining bytes to a new ByteArray			this.contentBytes = new ByteArray();			this.bytes.readBytes(this.contentBytes, 0, this.bytes.bytesAvailable);			this.content = new Array();						//parse the contentBytes to get the OSC Bundles subbundles or messages			getSubPackets();		}				/**		 * Returns the subpacket of this OSCPacket with the specified index		 * 		 * @param	pos The index of the subpacket		 * @return An OSCPacket if the given index is valid, else null		 */		public function getContent(pos:uint):OSCPacket {			if(pos < content.length){				return content[pos];			} else {				return null;			}		}			/**		 * Returns all subpackets of this OSCBundle		 * 		 * @return An Array containing OSCPackets		 */		public function get subPackets():Array {			return this.content;		}				/**		 * Returns the number of subpackets in this OSCBundle		 * 		 * @return The number of subpackets		 */		public function get subPacketCount():uint {			return this.content.length;		}				/**		 * Parses the contentBytes for additional OSCBundles or OSCMessages within this OSCBundle		 */		private function getSubPackets():void {			while (this.contentBytes.bytesAvailable > 0) {				var blockLength:int = this.contentBytes.readInt();				var cBytes:ByteArray = new ByteArray();				this.contentBytes.readBytes(cBytes, 0, blockLength);								if (isBundle(cBytes)) {					this.content.push(new OSCBundle(cBytes));				} else {					this.content.push(new OSCMessage(cBytes));				}			}		}				/**		 * Generates a String representation of this OSCBundle and its subpackets for debugging purposes		 * 		 * @return traceable String		 */		public override function getPacketInfo():String {			var out:String = new String();			out += "\nSeconds: " + this.timeSeconds.toString();			out += "\nPicoseconds: " + this.timePicoseconds.toString();			out += "\nSubPackets: " + this.subPacketCount.toString();			for each(var item:OSCPacket in content) {				out += item.getPacketInfo();			}			return out;		}				/**		 * Checks if the given ByteArray is an OSCBundle		 * 		 * @param	bytes The ByteArray to be checked.		 * @return true if the ByteArray contains an OSCBundle		 */		public static function isBundle(bytes:ByteArray):Boolean {			if (bytes != null) {				if (bytes.bytesAvailable >= 8) {					bytes.position = 0;					var header:String = bytes.readUTFBytes(8);					bytes.position = 0;					if (header == "#bundle") {						return true;					} else {						return false;					}				} else {					return false;				}			} else {				return false;			}		}			}	}